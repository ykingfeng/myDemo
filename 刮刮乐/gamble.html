<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>刮刮乐</title>
    <style>
    #mycanvas {
        border: 1px solid black;
        /* background: url("./getprize.jpg"); */
        /* width: 400px;
        height: 400px; */
        background-position: center ;
        background-size: cover;

    
    }
    </style>
</head>
<body>
    <canvas id="mycanvas" width="400" height="400"></canvas>
    <script>
    var myCanvas=document.getElementById("mycanvas");
    var ctx=myCanvas.getContext("2d");
    var w=myCanvas.width;
    var h=myCanvas.height;
    // console.log(w);
    var lastPos={};//当然要写在全局作用域下
    function init() {
        //随机数，控制抽到有奖图片的概率
        var img=new Image();

        var random=Math.random();
        if(random <0.4) {
            img.src="getprize.jpg";
        }
        else {
            img.src="lose.jpg";
        }
        img.onload=function () {
            myCanvas.style.backgroundImage="url("+ img.src +")";
            //按下鼠标，刮开灰色区域
            myCanvas.addEventListener("mousedown",downFunc);
        }
        // 给刮刮乐加上灰色幕布
        ctx.beginPath();
        ctx.fillStyle="#aaa";
        ctx.fillRect(0,0,w,h);
        ctx.globalCompositeOperation="destination-out";
    }
    init();
    
    function downFunc(e) {
        lastPos.x=e.clientX-myCanvas.offsetLeft;
        lastPos.y=e.clientY-myCanvas.offsetTop;
        
        ctx.beginPath();
        ctx.arc(lastPos.x,lastPos.y,20,0,Math.PI*2);//按下时，也能抹除灰色涂层，露出一部分背景
        ctx.closePath();    
        ctx.fill(); 

        myCanvas.addEventListener("mousemove",moveFunc)
        document.body.addEventListener("mouseup",upFunc);
        }
    function moveFunc(e) {//mousemove无法快速响应连读点击时露出背景，从而出现断点，所以要对点击的点之间做链接，串到一起消掉涂层
        var x=e.clientX-myCanvas.offsetLeft;
        var y=e.clientY-myCanvas.offsetTop;
        ctx.beginPath();
        ctx.moveTo(lastPos.x,lastPos.y);
        ctx.lineTo(x,y);
        ctx.lineWidth=40;
        ctx.lineCap="round";
        ctx.stroke();

        // ctx.beginPath();
        // ctx.arc(x,y,20,0,Math.PI*2);当启用这个时，按住鼠标快速拖动，让鼠标在canvas和以外的区域之间来回，接着不松手鼠标到canvas以外区域，再松开鼠标，再滑动鼠标进入canvas区域，依然有消除涂层的作用
        // ctx.closePath();    此外，点跟点相连，已经基本达到了拖动鼠标消除涂层的作用，
        // ctx.fill(); 

        lastPos.x=x;
        lastPos.y=y;//每次都会更新其实的那个moveTo的点

        }
    function upFunc() {
        myCanvas.removeEventListener("mousemove",moveFunc);
        document.body.removeEventListener("mouseup",upFunc);
        clearFunc();
        }
    function clearFunc() {
        var imgData=ctx.getImageData(0,0,w,h);//牢记讲的那个每个像素的rgba
        var len=imgData.data.length;
        var num=0;
        for(var i=0;i < len;i+=4) {
            if(imgData.data[i]==0) {
                num++;
            }
        }
        //等循环完毕所有的rgba的a，再判断
        if(num >= w*h*0.7) {
            ctx.clearRect(0,0,w,h);
        }
        }
    
    </script>
</body>
</html>